import "./chunk-OROXOI2D.js";

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/@material/base/foundation.js
var MDCFoundation = function() {
  function MDCFoundation2(adapter) {
    if (adapter === void 0) {
      adapter = {};
    }
    this.adapter = adapter;
  }
  Object.defineProperty(MDCFoundation2, "cssClasses", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "strings", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "numbers", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCFoundation2, "defaultAdapter", {
    get: function() {
      return {};
    },
    enumerable: false,
    configurable: true
  });
  MDCFoundation2.prototype.init = function() {
  };
  MDCFoundation2.prototype.destroy = function() {
  };
  return MDCFoundation2;
}();

// node_modules/@material/segmented-button/segmented-button/constants.js
var selectors = {
  SEGMENT: ".mdc-segmented-button__segment"
};
var events = {
  SELECTED: "selected",
  CHANGE: "change"
};
var cssClasses = {
  SINGLE_SELECT: "mdc-segmented-button--single-select"
};

// node_modules/@material/segmented-button/segmented-button/foundation.js
var MDCSegmentedButtonFoundation = function(_super) {
  __extends(MDCSegmentedButtonFoundation2, _super);
  function MDCSegmentedButtonFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCSegmentedButtonFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCSegmentedButtonFoundation2, "defaultAdapter", {
    get: function() {
      return {
        hasClass: function() {
          return false;
        },
        getSegments: function() {
          return [];
        },
        selectSegment: function() {
          return void 0;
        },
        unselectSegment: function() {
          return void 0;
        },
        notifySelectedChange: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSegmentedButtonFoundation2.prototype.selectSegment = function(indexOrSegmentId) {
    this.adapter.selectSegment(indexOrSegmentId);
  };
  MDCSegmentedButtonFoundation2.prototype.unselectSegment = function(indexOrSegmentId) {
    this.adapter.unselectSegment(indexOrSegmentId);
  };
  MDCSegmentedButtonFoundation2.prototype.getSelectedSegments = function() {
    return this.adapter.getSegments().filter(function(segmentDetail) {
      return segmentDetail.selected;
    });
  };
  MDCSegmentedButtonFoundation2.prototype.isSegmentSelected = function(indexOrSegmentId) {
    return this.adapter.getSegments().some(function(segmentDetail) {
      return (segmentDetail.index === indexOrSegmentId || segmentDetail.segmentId === indexOrSegmentId) && segmentDetail.selected;
    });
  };
  MDCSegmentedButtonFoundation2.prototype.isSingleSelect = function() {
    return this.adapter.hasClass(cssClasses.SINGLE_SELECT);
  };
  MDCSegmentedButtonFoundation2.prototype.handleSelected = function(detail) {
    if (this.isSingleSelect()) {
      this.unselectPrevSelected(detail.index);
    }
    this.adapter.notifySelectedChange(detail);
  };
  MDCSegmentedButtonFoundation2.prototype.unselectPrevSelected = function(index) {
    var e_1, _a;
    try {
      for (var _b = __values(this.getSelectedSegments()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var selectedSegment = _c.value;
        if (selectedSegment.index !== index) {
          this.unselectSegment(selectedSegment.index);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  return MDCSegmentedButtonFoundation2;
}(MDCFoundation);

// node_modules/@material/base/component.js
var MDCComponent = function() {
  function MDCComponent2(root, foundation) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    this.root = root;
    this.initialize.apply(this, __spreadArray([], __read(args)));
    this.foundation = foundation === void 0 ? this.getDefaultFoundation() : foundation;
    this.foundation.init();
    this.initialSyncWithDOM();
  }
  MDCComponent2.attachTo = function(root) {
    return new MDCComponent2(root, new MDCFoundation({}));
  };
  MDCComponent2.prototype.initialize = function() {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      _args[_i] = arguments[_i];
    }
  };
  MDCComponent2.prototype.getDefaultFoundation = function() {
    throw new Error("Subclasses must override getDefaultFoundation to return a properly configured foundation class");
  };
  MDCComponent2.prototype.initialSyncWithDOM = function() {
  };
  MDCComponent2.prototype.destroy = function() {
    this.foundation.destroy();
  };
  MDCComponent2.prototype.listen = function(evtType, handler, options) {
    this.root.addEventListener(evtType, handler, options);
  };
  MDCComponent2.prototype.unlisten = function(evtType, handler, options) {
    this.root.removeEventListener(evtType, handler, options);
  };
  MDCComponent2.prototype.emit = function(evtType, evtData, shouldBubble) {
    if (shouldBubble === void 0) {
      shouldBubble = false;
    }
    var evt;
    if (typeof CustomEvent === "function") {
      evt = new CustomEvent(evtType, {
        bubbles: shouldBubble,
        detail: evtData
      });
    } else {
      evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    this.root.dispatchEvent(evt);
  };
  return MDCComponent2;
}();

// node_modules/@material/dom/events.js
function applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options);
    globalObj.document.removeEventListener("test", handler, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}

// node_modules/@material/dom/ponyfill.js
function matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}

// node_modules/@material/ripple/constants.js
var cssClasses2 = {
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
};

// node_modules/@material/ripple/util.js
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS && typeof CSS.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS.supports("(--css-vars: yes)") && CSS.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x = pageOffset.x, y = pageOffset.y;
  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}

// node_modules/@material/ripple/foundation.js
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = function(_super) {
  __extends(MDCRippleFoundation2, _super);
  function MDCRippleFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
    _this.activationAnimationHasEnded = false;
    _this.activationTimer = 0;
    _this.fgDeactivationRemovalTimer = 0;
    _this.fgScale = "0";
    _this.frame = { width: 0, height: 0 };
    _this.initialSize = 0;
    _this.layoutFrame = 0;
    _this.maxRadius = 0;
    _this.unboundedCoords = { left: 0, top: 0 };
    _this.activationState = _this.defaultActivationState();
    _this.activationTimerCallback = function() {
      _this.activationAnimationHasEnded = true;
      _this.runDeactivationUXLogicIfReady();
    };
    _this.activateHandler = function(e) {
      _this.activateImpl(e);
    };
    _this.deactivateHandler = function() {
      _this.deactivateImpl();
    };
    _this.focusHandler = function() {
      _this.handleFocus();
    };
    _this.blurHandler = function() {
      _this.handleBlur();
    };
    _this.resizeHandler = function() {
      _this.layout();
    };
    return _this;
  }
  Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        browserSupportsCssVars: function() {
          return true;
        },
        computeBoundingRect: function() {
          return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
        },
        containsEventTarget: function() {
          return true;
        },
        deregisterDocumentInteractionHandler: function() {
          return void 0;
        },
        deregisterInteractionHandler: function() {
          return void 0;
        },
        deregisterResizeHandler: function() {
          return void 0;
        },
        getWindowPageOffset: function() {
          return { x: 0, y: 0 };
        },
        isSurfaceActive: function() {
          return true;
        },
        isSurfaceDisabled: function() {
          return true;
        },
        isUnbounded: function() {
          return true;
        },
        registerDocumentInteractionHandler: function() {
          return void 0;
        },
        registerInteractionHandler: function() {
          return void 0;
        },
        registerResizeHandler: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        updateCssVariable: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCRippleFoundation2.prototype.init = function() {
    var _this = this;
    var supportsPressRipple = this.supportsPressRipple();
    this.registerRootHandlers(supportsPressRipple);
    if (supportsPressRipple) {
      var _a = MDCRippleFoundation2.cssClasses, ROOT_1 = _a.ROOT, UNBOUNDED_1 = _a.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.addClass(ROOT_1);
        if (_this.adapter.isUnbounded()) {
          _this.adapter.addClass(UNBOUNDED_1);
          _this.layoutInternal();
        }
      });
    }
  };
  MDCRippleFoundation2.prototype.destroy = function() {
    var _this = this;
    if (this.supportsPressRipple()) {
      if (this.activationTimer) {
        clearTimeout(this.activationTimer);
        this.activationTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
      }
      if (this.fgDeactivationRemovalTimer) {
        clearTimeout(this.fgDeactivationRemovalTimer);
        this.fgDeactivationRemovalTimer = 0;
        this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
      }
      var _a = MDCRippleFoundation2.cssClasses, ROOT_2 = _a.ROOT, UNBOUNDED_2 = _a.UNBOUNDED;
      requestAnimationFrame(function() {
        _this.adapter.removeClass(ROOT_2);
        _this.adapter.removeClass(UNBOUNDED_2);
        _this.removeCssVars();
      });
    }
    this.deregisterRootHandlers();
    this.deregisterDeactivationHandlers();
  };
  MDCRippleFoundation2.prototype.activate = function(evt) {
    this.activateImpl(evt);
  };
  MDCRippleFoundation2.prototype.deactivate = function() {
    this.deactivateImpl();
  };
  MDCRippleFoundation2.prototype.layout = function() {
    var _this = this;
    if (this.layoutFrame) {
      cancelAnimationFrame(this.layoutFrame);
    }
    this.layoutFrame = requestAnimationFrame(function() {
      _this.layoutInternal();
      _this.layoutFrame = 0;
    });
  };
  MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
    var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
    if (unbounded) {
      this.adapter.addClass(UNBOUNDED);
    } else {
      this.adapter.removeClass(UNBOUNDED);
    }
  };
  MDCRippleFoundation2.prototype.handleFocus = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.handleBlur = function() {
    var _this = this;
    requestAnimationFrame(function() {
      return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
    });
  };
  MDCRippleFoundation2.prototype.supportsPressRipple = function() {
    return this.adapter.browserSupportsCssVars();
  };
  MDCRippleFoundation2.prototype.defaultActivationState = function() {
    return {
      activationEvent: void 0,
      hasDeactivationUXRun: false,
      isActivated: false,
      isProgrammatic: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false
    };
  };
  MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
    var e_1, _a;
    if (supportsPressRipple) {
      try {
        for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a = ACTIVATION_EVENT_TYPES_1.return))
            _a.call(ACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (this.adapter.isUnbounded()) {
        this.adapter.registerResizeHandler(this.resizeHandler);
      }
    }
    this.adapter.registerInteractionHandler("focus", this.focusHandler);
    this.adapter.registerInteractionHandler("blur", this.blurHandler);
  };
  MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
    var e_2, _a;
    if (evt.type === "keydown") {
      this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
    } else {
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
          this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_1.return))
            _a.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  };
  MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
    var e_3, _a;
    try {
      for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a = ACTIVATION_EVENT_TYPES_2.return))
          _a.call(ACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
    this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
    this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
    if (this.adapter.isUnbounded()) {
      this.adapter.deregisterResizeHandler(this.resizeHandler);
    }
  };
  MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
    var e_4, _a;
    this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
    try {
      for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
        var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
        this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a = POINTER_DEACTIVATION_EVENT_TYPES_2.return))
          _a.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
      } finally {
        if (e_4)
          throw e_4.error;
      }
    }
  };
  MDCRippleFoundation2.prototype.removeCssVars = function() {
    var _this = this;
    var rippleStrings = MDCRippleFoundation2.strings;
    var keys = Object.keys(rippleStrings);
    keys.forEach(function(key) {
      if (key.indexOf("VAR_") === 0) {
        _this.adapter.updateCssVariable(rippleStrings[key], null);
      }
    });
  };
  MDCRippleFoundation2.prototype.activateImpl = function(evt) {
    var _this = this;
    if (this.adapter.isSurfaceDisabled()) {
      return;
    }
    var activationState = this.activationState;
    if (activationState.isActivated) {
      return;
    }
    var previousActivationEvent = this.previousActivationEvent;
    var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
    if (isSameInteraction) {
      return;
    }
    activationState.isActivated = true;
    activationState.isProgrammatic = evt === void 0;
    activationState.activationEvent = evt;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
    var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
      return _this.adapter.containsEventTarget(target);
    });
    if (hasActivatedChild) {
      this.resetActivationState();
      return;
    }
    if (evt !== void 0) {
      activatedTargets.push(evt.target);
      this.registerDeactivationHandlers(evt);
    }
    activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
    if (activationState.wasElementMadeActive) {
      this.animateActivation();
    }
    requestAnimationFrame(function() {
      activatedTargets = [];
      if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
        activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
        if (activationState.wasElementMadeActive) {
          _this.animateActivation();
        }
      }
      if (!activationState.wasElementMadeActive) {
        _this.activationState = _this.defaultActivationState();
      }
    });
  };
  MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
    return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
  };
  MDCRippleFoundation2.prototype.animateActivation = function() {
    var _this = this;
    var _a = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a.VAR_FG_TRANSLATE_END;
    var _b = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b.FG_DEACTIVATION, FG_ACTIVATION = _b.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
    this.layoutInternal();
    var translateStart = "";
    var translateEnd = "";
    if (!this.adapter.isUnbounded()) {
      var _c = this.getFgTranslationCoordinates(), startPoint = _c.startPoint, endPoint = _c.endPoint;
      translateStart = startPoint.x + "px, " + startPoint.y + "px";
      translateEnd = endPoint.x + "px, " + endPoint.y + "px";
    }
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    clearTimeout(this.activationTimer);
    clearTimeout(this.fgDeactivationRemovalTimer);
    this.rmBoundedActivationClasses();
    this.adapter.removeClass(FG_DEACTIVATION);
    this.adapter.computeBoundingRect();
    this.adapter.addClass(FG_ACTIVATION);
    this.activationTimer = setTimeout(function() {
      _this.activationTimerCallback();
    }, DEACTIVATION_TIMEOUT_MS);
  };
  MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
    var _a = this.activationState, activationEvent = _a.activationEvent, wasActivatedByPointer = _a.wasActivatedByPointer;
    var startPoint;
    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame.width / 2,
        y: this.frame.height / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize / 2,
      y: startPoint.y - this.initialSize / 2
    };
    var endPoint = {
      x: this.frame.width / 2 - this.initialSize / 2,
      y: this.frame.height / 2 - this.initialSize / 2
    };
    return { startPoint, endPoint };
  };
  MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
    var _this = this;
    var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
    var _a = this.activationState, hasDeactivationUXRun = _a.hasDeactivationUXRun, isActivated = _a.isActivated;
    var activationHasEnded = hasDeactivationUXRun || !isActivated;
    if (activationHasEnded && this.activationAnimationHasEnded) {
      this.rmBoundedActivationClasses();
      this.adapter.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer = setTimeout(function() {
        _this.adapter.removeClass(FG_DEACTIVATION);
      }, numbers.FG_DEACTIVATION_MS);
    }
  };
  MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
    var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
    this.adapter.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded = false;
    this.adapter.computeBoundingRect();
  };
  MDCRippleFoundation2.prototype.resetActivationState = function() {
    var _this = this;
    this.previousActivationEvent = this.activationState.activationEvent;
    this.activationState = this.defaultActivationState();
    setTimeout(function() {
      return _this.previousActivationEvent = void 0;
    }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
  };
  MDCRippleFoundation2.prototype.deactivateImpl = function() {
    var _this = this;
    var activationState = this.activationState;
    if (!activationState.isActivated) {
      return;
    }
    var state = __assign({}, activationState);
    if (activationState.isProgrammatic) {
      requestAnimationFrame(function() {
        _this.animateDeactivation(state);
      });
      this.resetActivationState();
    } else {
      this.deregisterDeactivationHandlers();
      requestAnimationFrame(function() {
        _this.activationState.hasDeactivationUXRun = true;
        _this.animateDeactivation(state);
        _this.resetActivationState();
      });
    }
  };
  MDCRippleFoundation2.prototype.animateDeactivation = function(_a) {
    var wasActivatedByPointer = _a.wasActivatedByPointer, wasElementMadeActive = _a.wasElementMadeActive;
    if (wasActivatedByPointer || wasElementMadeActive) {
      this.runDeactivationUXLogicIfReady();
    }
  };
  MDCRippleFoundation2.prototype.layoutInternal = function() {
    var _this = this;
    this.frame = this.adapter.computeBoundingRect();
    var maxDim = Math.max(this.frame.height, this.frame.width);
    var getBoundedRadius = function() {
      var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
      return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
    };
    this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
    var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
    if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
      this.initialSize = initialSize - 1;
    } else {
      this.initialSize = initialSize;
    }
    this.fgScale = "" + this.maxRadius / this.initialSize;
    this.updateLayoutCssVars();
  };
  MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
    var _a = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a.VAR_FG_SIZE, VAR_LEFT = _a.VAR_LEFT, VAR_TOP = _a.VAR_TOP, VAR_FG_SCALE = _a.VAR_FG_SCALE;
    this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
    this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
    if (this.adapter.isUnbounded()) {
      this.unboundedCoords = {
        left: Math.round(this.frame.width / 2 - this.initialSize / 2),
        top: Math.round(this.frame.height / 2 - this.initialSize / 2)
      };
      this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
      this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
    }
  };
  return MDCRippleFoundation2;
}(MDCFoundation);

// node_modules/@material/ripple/component.js
var MDCRipple = function(_super) {
  __extends(MDCRipple2, _super);
  function MDCRipple2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.disabled = false;
    return _this;
  }
  MDCRipple2.attachTo = function(root, opts) {
    if (opts === void 0) {
      opts = {
        isUnbounded: void 0
      };
    }
    var ripple = new MDCRipple2(root);
    if (opts.isUnbounded !== void 0) {
      ripple.unbounded = opts.isUnbounded;
    }
    return ripple;
  };
  MDCRipple2.createAdapter = function(instance) {
    return {
      addClass: function(className) {
        return instance.root.classList.add(className);
      },
      browserSupportsCssVars: function() {
        return supportsCssVariables(window);
      },
      computeBoundingRect: function() {
        return instance.root.getBoundingClientRect();
      },
      containsEventTarget: function(target) {
        return instance.root.contains(target);
      },
      deregisterDocumentInteractionHandler: function(evtType, handler) {
        return document.documentElement.removeEventListener(evtType, handler, applyPassive());
      },
      deregisterInteractionHandler: function(evtType, handler) {
        return instance.root.removeEventListener(evtType, handler, applyPassive());
      },
      deregisterResizeHandler: function(handler) {
        return window.removeEventListener("resize", handler);
      },
      getWindowPageOffset: function() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      },
      isSurfaceActive: function() {
        return matches(instance.root, ":active");
      },
      isSurfaceDisabled: function() {
        return Boolean(instance.disabled);
      },
      isUnbounded: function() {
        return Boolean(instance.unbounded);
      },
      registerDocumentInteractionHandler: function(evtType, handler) {
        return document.documentElement.addEventListener(evtType, handler, applyPassive());
      },
      registerInteractionHandler: function(evtType, handler) {
        return instance.root.addEventListener(evtType, handler, applyPassive());
      },
      registerResizeHandler: function(handler) {
        return window.addEventListener("resize", handler);
      },
      removeClass: function(className) {
        return instance.root.classList.remove(className);
      },
      updateCssVariable: function(varName, value) {
        return instance.root.style.setProperty(varName, value);
      }
    };
  };
  Object.defineProperty(MDCRipple2.prototype, "unbounded", {
    get: function() {
      return Boolean(this.isUnbounded);
    },
    set: function(unbounded) {
      this.isUnbounded = Boolean(unbounded);
      this.setUnbounded();
    },
    enumerable: false,
    configurable: true
  });
  MDCRipple2.prototype.activate = function() {
    this.foundation.activate();
  };
  MDCRipple2.prototype.deactivate = function() {
    this.foundation.deactivate();
  };
  MDCRipple2.prototype.layout = function() {
    this.foundation.layout();
  };
  MDCRipple2.prototype.getDefaultFoundation = function() {
    return new MDCRippleFoundation(MDCRipple2.createAdapter(this));
  };
  MDCRipple2.prototype.initialSyncWithDOM = function() {
    var root = this.root;
    this.isUnbounded = "mdcRippleIsUnbounded" in root.dataset;
  };
  MDCRipple2.prototype.setUnbounded = function() {
    this.foundation.setUnbounded(Boolean(this.isUnbounded));
  };
  return MDCRipple2;
}(MDCComponent);

// node_modules/@material/segmented-button/segment/constants.js
var booleans = {
  TRUE: "true",
  FALSE: "false"
};
var attributes = {
  ARIA_CHECKED: "aria-checked",
  ARIA_PRESSED: "aria-pressed",
  DATA_SEGMENT_ID: "data-segment-id"
};
var events2 = {
  CLICK: "click",
  SELECTED: "selected"
};
var cssClasses3 = {
  SELECTED: "mdc-segmented-button__segment--selected"
};

// node_modules/@material/segmented-button/segment/foundation.js
var emptyClientRect = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0
};
var MDCSegmentedButtonSegmentFoundation = function(_super) {
  __extends(MDCSegmentedButtonSegmentFoundation2, _super);
  function MDCSegmentedButtonSegmentFoundation2(adapter) {
    return _super.call(this, __assign(__assign({}, MDCSegmentedButtonSegmentFoundation2.defaultAdapter), adapter)) || this;
  }
  Object.defineProperty(MDCSegmentedButtonSegmentFoundation2, "defaultAdapter", {
    get: function() {
      return {
        isSingleSelect: function() {
          return false;
        },
        getAttr: function() {
          return "";
        },
        setAttr: function() {
          return void 0;
        },
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        notifySelectedChange: function() {
          return void 0;
        },
        getRootBoundingClientRect: function() {
          return emptyClientRect;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSegmentedButtonSegmentFoundation2.prototype.isSelected = function() {
    return this.adapter.hasClass(cssClasses3.SELECTED);
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.setSelected = function() {
    this.adapter.addClass(cssClasses3.SELECTED);
    this.setAriaAttr(booleans.TRUE);
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.setUnselected = function() {
    this.adapter.removeClass(cssClasses3.SELECTED);
    this.setAriaAttr(booleans.FALSE);
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.getSegmentId = function() {
    var _a;
    return (_a = this.adapter.getAttr(attributes.DATA_SEGMENT_ID)) !== null && _a !== void 0 ? _a : void 0;
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.handleClick = function() {
    if (this.adapter.isSingleSelect()) {
      this.setSelected();
    } else {
      this.toggleSelection();
    }
    this.adapter.notifySelectedChange(this.isSelected());
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.getDimensions = function() {
    return this.adapter.getRootBoundingClientRect();
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.toggleSelection = function() {
    if (this.isSelected()) {
      this.setUnselected();
    } else {
      this.setSelected();
    }
  };
  MDCSegmentedButtonSegmentFoundation2.prototype.setAriaAttr = function(value) {
    if (this.adapter.isSingleSelect()) {
      this.adapter.setAttr(attributes.ARIA_CHECKED, value);
    } else {
      this.adapter.setAttr(attributes.ARIA_PRESSED, value);
    }
  };
  return MDCSegmentedButtonSegmentFoundation2;
}(MDCFoundation);

// node_modules/@material/segmented-button/segment/component.js
var MDCSegmentedButtonSegment = function(_super) {
  __extends(MDCSegmentedButtonSegment2, _super);
  function MDCSegmentedButtonSegment2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MDCSegmentedButtonSegment2.prototype, "ripple", {
    get: function() {
      return this.rippleComponent;
    },
    enumerable: false,
    configurable: true
  });
  MDCSegmentedButtonSegment2.attachTo = function(root) {
    return new MDCSegmentedButtonSegment2(root);
  };
  MDCSegmentedButtonSegment2.prototype.initialize = function(rippleFactory) {
    var _this = this;
    if (rippleFactory === void 0) {
      rippleFactory = function(el, foundation) {
        return new MDCRipple(el, foundation);
      };
    }
    var rippleAdapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { computeBoundingRect: function() {
      return _this.foundation.getDimensions();
    } });
    this.rippleComponent = rippleFactory(this.root, new MDCRippleFoundation(rippleAdapter));
  };
  MDCSegmentedButtonSegment2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleClick = function() {
      _this.foundation.handleClick();
    };
    this.listen(events2.CLICK, this.handleClick);
  };
  MDCSegmentedButtonSegment2.prototype.destroy = function() {
    this.ripple.destroy();
    this.unlisten(events2.CLICK, this.handleClick);
    _super.prototype.destroy.call(this);
  };
  MDCSegmentedButtonSegment2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      isSingleSelect: function() {
        return _this.isSingleSelect;
      },
      getAttr: function(attrName) {
        return _this.root.getAttribute(attrName);
      },
      setAttr: function(attrName, value) {
        _this.root.setAttribute(attrName, value);
      },
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      notifySelectedChange: function(selected) {
        _this.emit(events2.SELECTED, {
          index: _this.index,
          selected,
          segmentId: _this.getSegmentId()
        }, true);
      },
      getRootBoundingClientRect: function() {
        return _this.root.getBoundingClientRect();
      }
    };
    return new MDCSegmentedButtonSegmentFoundation(adapter);
  };
  MDCSegmentedButtonSegment2.prototype.setIndex = function(index) {
    this.index = index;
  };
  MDCSegmentedButtonSegment2.prototype.setIsSingleSelect = function(isSingleSelect) {
    this.isSingleSelect = isSingleSelect;
  };
  MDCSegmentedButtonSegment2.prototype.isSelected = function() {
    return this.foundation.isSelected();
  };
  MDCSegmentedButtonSegment2.prototype.setSelected = function() {
    this.foundation.setSelected();
  };
  MDCSegmentedButtonSegment2.prototype.setUnselected = function() {
    this.foundation.setUnselected();
  };
  MDCSegmentedButtonSegment2.prototype.getSegmentId = function() {
    return this.foundation.getSegmentId();
  };
  return MDCSegmentedButtonSegment2;
}(MDCComponent);

// node_modules/@material/segmented-button/segmented-button/component.js
var MDCSegmentedButton = function(_super) {
  __extends(MDCSegmentedButton2, _super);
  function MDCSegmentedButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MDCSegmentedButton2.attachTo = function(root) {
    return new MDCSegmentedButton2(root);
  };
  Object.defineProperty(MDCSegmentedButton2.prototype, "segments", {
    get: function() {
      return this.segmentsList.slice();
    },
    enumerable: false,
    configurable: true
  });
  MDCSegmentedButton2.prototype.initialize = function(segmentFactory) {
    if (segmentFactory === void 0) {
      segmentFactory = function(el) {
        return new MDCSegmentedButtonSegment(el);
      };
    }
    this.segmentFactory = segmentFactory;
    this.segmentsList = this.instantiateSegments(this.segmentFactory);
  };
  MDCSegmentedButton2.prototype.instantiateSegments = function(segmentFactory) {
    var segmentElements = [].slice.call(this.root.querySelectorAll(selectors.SEGMENT));
    return segmentElements.map(function(el) {
      return segmentFactory(el);
    });
  };
  MDCSegmentedButton2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleSelected = function(event) {
      _this.foundation.handleSelected(event.detail);
    };
    this.listen(events.SELECTED, this.handleSelected);
    var isSingleSelect = this.foundation.isSingleSelect();
    for (var i = 0; i < this.segmentsList.length; i++) {
      var segment = this.segmentsList[i];
      segment.setIndex(i);
      segment.setIsSingleSelect(isSingleSelect);
    }
    var selectedSegments = this.segmentsList.filter(function(segment2) {
      return segment2.isSelected();
    });
    if (isSingleSelect && selectedSegments.length === 0 && this.segmentsList.length > 0) {
      throw new Error("No segment selected in singleSelect mdc-segmented-button");
    } else if (isSingleSelect && selectedSegments.length > 1) {
      throw new Error("Multiple segments selected in singleSelect mdc-segmented-button");
    }
  };
  MDCSegmentedButton2.prototype.destroy = function() {
    var e_1, _a;
    try {
      for (var _b = __values(this.segmentsList), _c = _b.next(); !_c.done; _c = _b.next()) {
        var segment = _c.value;
        segment.destroy();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.unlisten(events.SELECTED, this.handleSelected);
    _super.prototype.destroy.call(this);
  };
  MDCSegmentedButton2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      getSegments: function() {
        return _this.mappedSegments();
      },
      selectSegment: function(indexOrSegmentId) {
        var segmentDetail = _this.mappedSegments().find(function(detail) {
          return detail.index === indexOrSegmentId || detail.segmentId === indexOrSegmentId;
        });
        if (segmentDetail) {
          _this.segmentsList[segmentDetail.index].setSelected();
        }
      },
      unselectSegment: function(indexOrSegmentId) {
        var segmentDetail = _this.mappedSegments().find(function(detail) {
          return detail.index === indexOrSegmentId || detail.segmentId === indexOrSegmentId;
        });
        if (segmentDetail) {
          _this.segmentsList[segmentDetail.index].setUnselected();
        }
      },
      notifySelectedChange: function(detail) {
        _this.emit(events.CHANGE, detail, true);
      }
    };
    return new MDCSegmentedButtonFoundation(adapter);
  };
  MDCSegmentedButton2.prototype.getSelectedSegments = function() {
    return this.foundation.getSelectedSegments();
  };
  MDCSegmentedButton2.prototype.selectSegment = function(indexOrSegmentId) {
    this.foundation.selectSegment(indexOrSegmentId);
  };
  MDCSegmentedButton2.prototype.unselectSegment = function(indexOrSegmentId) {
    this.foundation.unselectSegment(indexOrSegmentId);
  };
  MDCSegmentedButton2.prototype.isSegmentSelected = function(indexOrSegmentId) {
    return this.foundation.isSegmentSelected(indexOrSegmentId);
  };
  MDCSegmentedButton2.prototype.mappedSegments = function() {
    return this.segmentsList.map(function(segment, index) {
      return {
        index,
        selected: segment.isSelected(),
        segmentId: segment.getSegmentId()
      };
    });
  };
  return MDCSegmentedButton2;
}(MDCComponent);
export {
  MDCSegmentedButton,
  MDCSegmentedButtonFoundation,
  MDCSegmentedButtonSegment,
  MDCSegmentedButtonSegmentFoundation
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@smui_segmented-button__@material_segmented-button.js.map
